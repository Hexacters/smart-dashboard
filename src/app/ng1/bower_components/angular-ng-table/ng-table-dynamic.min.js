(function(angular, factory) {
    'use strict';

    if (typeof define === 'function' && define.amd) {
        define(['angular'], function(angular) {
            return factory(angular);
        });
    } else {
        return factory(angular);
    }
}(window.angular || null, function(angular) {
    'use strict';

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

/**
 * @ngdoc module
 * @name ngTable
 * @description ngTable: Table + Angular JS
 * @example
 <doc:example>
 <doc:source>
 <script>
 var app = angular.module('myApp', ['ngTable']);
 app.controller('MyCtrl', function($scope) {
                    $scope.users = [
                        {name: "Moroni", age: 50},
                        {name: "Tiancum", age: 43},
                        {name: "Jacob", age: 27},
                        {name: "Nephi", age: 29},
                        {name: "Enos", age: 34}
                    ];
                });
 </script>
 <table ng-table class="table">
 <tr ng-repeat="user in users">
 <td data-title="'Name'">{{user.name}}</td>
 <td data-title="'Age'">{{user.age}}</td>
 </tr>
 </table>
 </doc:source>
 </doc:example>
 */
var app = angular.module('ngTable', []);
/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(){
    'use strict';

    angular.module('ngTable')
        .factory('ngTableEventsChannel', ngTableEventsChannel);

    ngTableEventsChannel.$inject = ['$rootScope'];

    /**
     * @ngdoc service
     * @name ngTableEventsChannel
     * @description strongly typed pub/sub for `NgTableParams`
     *
     * Supported events:
     *
     * * afterCreated - raised when a new instance of `NgTableParams` has finished being constructed
     * * afterReloadData - raised when the `reload` event has finished loading new data
     * * datasetChanged - raised when `settings` receives a new data array
     * * pagesChanged - raised when a new pages array has been generated
     */
    function ngTableEventsChannel($rootScope){

        var events = {};
        events = addChangeEvent('afterCreated', events);
        events = addChangeEvent('afterReloadData', events);
        events = addChangeEvent('datasetChanged', events);
        events = addChangeEvent('pagesChanged', events);
        return events;

        //////////

        function addChangeEvent(eventName, target){
            var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);
            var event = {};
            event['on' + fnName] = createEventSubscriptionFn(eventName);
            event['publish' + fnName] = createPublishEventFn(eventName);
            return angular.extend(target, event);
        }

        function createEventSubscriptionFn(eventName){

            return function subscription(handler/*[, eventSelector or $scope][, eventSelector]*/){
                var eventSelector = angular.identity;
                var scope = $rootScope;

                if (arguments.length === 2){
                    if (angular.isFunction(arguments[1].$new)) {
                        scope = arguments[1];
                    } else {
                        eventSelector = arguments[1]
                    }
                } else if (arguments.length > 2){
                    scope = arguments[1];
                    eventSelector = arguments[2];
                }

                // shorthand for subscriber to only receive events from a specific publisher instance
                if (angular.isObject(eventSelector)) {
                    var requiredPublisher = eventSelector;
                    eventSelector = function(publisher){
                        return publisher === requiredPublisher;
                    }
                }

                return scope.$on('ngTable:' + eventName, function(event, params/*, ...args*/){
                    // don't send events published by the internal NgTableParams created by ngTableController
                    if (params.isNullInstance) return;

                    var eventArgs = rest(arguments, 2);
                    var fnArgs = [params].concat(eventArgs);
                    if (eventSelector.apply(this, fnArgs)){
                        handler.apply(this, fnArgs);
                    }
                });
            }
        }

        function createPublishEventFn(eventName){
            return function publish(/*args*/){
                var fnArgs = ['ngTable:' + eventName].concat(Array.prototype.slice.call(arguments));
                $rootScope.$broadcast.apply($rootScope, fnArgs);
            }
        }

        function rest(array, n) {
            return Array.prototype.slice.call(array, n == null ? 1 : n);
        }
    }
})();

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(){
    'use strict';

    angular.module('ngTable')
        .provider('ngTableFilterConfig', ngTableFilterConfigProvider);

    ngTableFilterConfigProvider.$inject = [];

    function ngTableFilterConfigProvider(){
        var config;
        var defaultConfig = {
            defaultBaseUrl: 'ng-table/filters/',
            defaultExt: '.html',
            aliasUrls: {}
        };

        this.$get = ngTableFilterConfig;
        this.resetConfigs = resetConfigs;
        this.setConfig = setConfig;

        init();

        /////////

        function init(){
            resetConfigs();
        }

        function resetConfigs(){
            config = defaultConfig;
        }

        function setConfig(customConfig){
            var mergeConfig = angular.extend({}, config, customConfig);
            mergeConfig.aliasUrls = angular.extend({}, config.aliasUrls, customConfig.aliasUrls);
            config = mergeConfig;
        }

        /////////

        ngTableFilterConfig.$inject = [];

        function ngTableFilterConfig(){

            var publicConfig;

            var service = {
                config: publicConfig,
                getTemplateUrl: getTemplateUrl,
                getUrlForAlias: getUrlForAlias
            };
            Object.defineProperty(service, "config", {
                get: function(){
                    return publicConfig = publicConfig || angular.copy(config);
                },
                enumerable: true
            });

            return service;

            /////////

            function getTemplateUrl(filterValue, filterKey){
                if (filterValue.indexOf('/') !== -1){
                    return filterValue;
                }

                return service.getUrlForAlias(filterValue, filterKey);
            }

            function getUrlForAlias(aliasName/*, filterKey*/){
                return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;
            }
        }
    }
})();

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(){
    'use strict';


    angular.module('ngTable')
        .provider('ngTableDefaultGetData', ngTableDefaultGetDataProvider);

    ngTableDefaultGetDataProvider.$inject = [];

    /**
     * @ngdoc provider
     * @name ngTableDefaultGetDataProvider
     * @description Allows for the configuration of the {@link ngTable.ngTableDefaultGetData ngTableDefaultGetData}
     * service.
     *
     * Set filterFilterName to the name of a angular filter that knows how to take `NgTableParams.filter()`
     * to restrict an array of data.
     *
     * Set sortingFilterName to the name of a angular filter that knows how to take `NgTableParams.orderBy()`
     * to sort an array of data.
     *
     * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`
     * filters respectively
     */
    function ngTableDefaultGetDataProvider(){
        var provider = this;
        provider.$get = ngTableDefaultGetData;
        provider.filterFilterName = 'filter';
        provider.sortingFilterName = 'orderBy';

        ///////////

        ngTableDefaultGetData.$inject = ['$filter'];

        /**
         * @ngdoc service
         * @name ngTableDefaultGetData
         * @description A default implementation of the getData function that will apply the `filter`, `orderBy` and
         * paging values from the `NgTableParams` instance supplied to the data array supplied.
         *
         * The outcome will be to return the resulting array and to assign the total item count after filtering
         * to the `total` of the `NgTableParams` instance supplied
         */
        function ngTableDefaultGetData($filter) {

            return getData;

            function getData(data, params) {
                if (data == null){
                    return [];
                }

                var fData = params.hasFilter() ? $filter(provider.filterFilterName)(data, params.filter()) : data;
                var orderBy = params.orderBy();
                var orderedData = orderBy.length ? $filter(provider.sortingFilterName)(fData, orderBy) : fData;
                var pagedData = orderedData.slice((params.page() - 1) * params.count(), params.page() * params.count());
                params.total(orderedData.length); // set total for recalc pagination
                return pagedData;
            }
        }
    }
})();

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(){
    'use strict';

    // todo: remove shim after an acceptable depreciation period

    angular.module('ngTable')
        .factory('ngTableGetDataBcShim', ngTableGetDataBcShim);

    ngTableGetDataBcShim.$inject = ['$q'];

    function ngTableGetDataBcShim($q){

        return createWrapper;

        function createWrapper(getDataFn){
            return function getDataShim(/*args*/){
                var $defer = $q.defer();
                var pData = getDataFn.apply(this, [$defer].concat(Array.prototype.slice.call(arguments)));
                if (!pData) {
                    // If getData resolved the $defer, and didn't promise us data,
                    //   create a promise from the $defer. We need to return a promise.
                    pData = $defer.promise;
                }
                return pData;
            }
        }
    }
})();

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

/**
 * @ngdoc object
 * @name ngTableDefaultParams
 * @module ngTable
 * @description Default Parameters for ngTable
 */
app.value('ngTableDefaults', {
    params: {},
    settings: {}
});

/**
 * @ngdoc service
 * @name NgTableParams
 * @module ngTable
 * @description Parameters manager for ngTable
 */

app.factory('NgTableParams', ['$q', '$log', 'ngTableDefaults', 'ngTableGetDataBcShim', 'ngTableDefaultGetData', 'ngTableEventsChannel', function($q, $log, ngTableDefaults, ngTableGetDataBcShim, ngTableDefaultGetData, ngTableEventsChannel) {
    var isNumber = function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    };
    var NgTableParams = function(baseParameters, baseSettings) {

        // the ngTableController "needs" to create a dummy/null instance and it's important to know whether an instance
        // is one of these
        if (typeof baseParameters === "boolean"){
            this.isNullInstance = true;
        }

        var self = this,
            committedParams,
            isCommittedDataset = false,
            log = function() {
                if (settings.debugMode && $log.debug) {
                    $log.debug.apply(this, arguments);
                }
            };

        this.data = [];

        /**
         * @ngdoc method
         * @name NgTableParams#parameters
         * @description Set new parameters or get current parameters
         *
         * @param {string} newParameters      New parameters
         * @param {string} parseParamsFromUrl Flag if parse parameters like in url
         * @returns {Object} Current parameters or `this`
         */
        this.parameters = function(newParameters, parseParamsFromUrl) {
            parseParamsFromUrl = parseParamsFromUrl || false;
            if (angular.isDefined(newParameters)) {
                for (var key in newParameters) {
                    var value = newParameters[key];
                    if (parseParamsFromUrl && key.indexOf('[') >= 0) {
                        var keys = key.split(/\[(.*)\]/).reverse()
                        var lastKey = '';
                        for (var i = 0, len = keys.length; i < len; i++) {
                            var name = keys[i];
                            if (name !== '') {
                                var v = value;
                                value = {};
                                value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);
                            }
                        }
                        if (lastKey === 'sorting') {
                            params[lastKey] = {};
                        }
                        params[lastKey] = angular.extend(params[lastKey] || {}, value[lastKey]);
                    } else {
                        params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);
                    }
                }
                log('ngTable: set parameters', params);
                return this;
            }
            return params;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#settings
         * @description Set new settings for table
         *
         * @param {string} newSettings New settings or undefined
         * @returns {Object} Current settings or `this`
         */
        this.settings = function(newSettings) {
            if (angular.isDefined(newSettings)) {
                if (angular.isArray(newSettings.data)) {
                    //auto-set the total from passed in data
                    newSettings.total = newSettings.data.length;
                }
                // note: using != as want null and undefined to be treated the same
                if (newSettings.hasOwnProperty('data') && (newSettings.data != settings.data)) {
                    if (isCommittedDataset){
                        this.page(1); // reset page as a new dataset has been supplied
                    }
                    isCommittedDataset = false;
                    ngTableEventsChannel.publishDatasetChanged(this, newSettings.data, settings.data);
                }

                // todo: remove the backwards compatibility shim and the following two if blocks
                if (newSettings.getData && newSettings.getData.length > 1){
                    // support the old getData($defer, params) api
                    newSettings.getDataFnAdaptor = ngTableGetDataBcShim;
                }
                if (newSettings.getGroups && newSettings.getGroups.length > 2){
                    // support the old getGroups($defer, grouping, params) api
                    newSettings.getGroupsFnAdaptor = ngTableGetDataBcShim;
                }

                settings = angular.extend(settings, newSettings);
                log('ngTable: set settings', settings);
                return this;
            }
            return settings;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#page
         * @description If parameter page not set return current page else set current page
         *
         * @param {string} page Page number
         * @returns {Object|Number} Current page or `this`
         */
        this.page = function(page) {
            return angular.isDefined(page) ? this.parameters({
                'page': page
            }) : params.page;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#total
         * @description If parameter total not set return current quantity else set quantity
         *
         * @param {string} total Total quantity of items
         * @returns {Object|Number} Current page or `this`
         */
        this.total = function(total) {
            return angular.isDefined(total) ? this.settings({
                'total': total
            }) : settings.total;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#count
         * @description If parameter count not set return current count per page else set count per page
         *
         * @param {string} count Count per number
         * @returns {Object|Number} Count per page or `this`
         */
        this.count = function(count) {
            // reset to first page because can be blank page
            return angular.isDefined(count) ? this.parameters({
                'count': count,
                'page': 1
            }) : params.count;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#filter
         * @description If parameter page not set return current filter else set current filter
         *
         * @param {string} filter New filter
         * @returns {Object} Current filter or `this`
         */
        this.filter = function(filter) {
            return angular.isDefined(filter) ? this.parameters({
                'filter': filter,
                'page': 1
            }) : params.filter;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#sorting
         * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.
         *
         * @param {string} sorting New sorting
         * @returns {Object} Current sorting or `this`
         */
        this.sorting = function(sorting) {
            if (arguments.length == 2) {
                var sortArray = {};
                sortArray[sorting] = arguments[1];
                this.parameters({
                    'sorting': sortArray
                });
                return this;
            }
            return angular.isDefined(sorting) ? this.parameters({
                'sorting': sorting
            }) : params.sorting;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#isSortBy
         * @description Checks sort field
         *
         * @param {string} field     Field name
         * @param {string} direction Direction of sorting 'asc' or 'desc'
         * @returns {Array} Return true if field sorted by direction
         */
        this.isSortBy = function(field, direction) {
            return angular.isDefined(params.sorting[field]) && angular.equals(params.sorting[field], direction);
        };

        /**
         * @ngdoc method
         * @name NgTableParams#orderBy
         * @description Return object of sorting parameters for angular filter
         *
         * @returns {Array} Array like: [ '-name', '+age' ]
         */
        this.orderBy = function() {
            var sorting = [];
            for (var column in params.sorting) {
                sorting.push((params.sorting[column] === "asc" ? "+" : "-") + column);
            }
            return sorting;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#getData
         * @description Called when updated some of parameters for get new data
         *
         * @param {Object} params New parameters
         */
        this.getData = function(params) {
            // note: this === settings
            return ngTableDefaultGetData(this.data, params);
        };

        /**
         * @ngdoc method
         * @name NgTableParams#getGroups
         * @description Return groups for table grouping
         */
        this.getGroups = function(column) {
            return runGetData().then(function(data) {
                var groups = {};
                angular.forEach(data, function(item) {
                    var groupName = angular.isFunction(column) ? column(item) : item[column];

                    groups[groupName] = groups[groupName] || {
                        data: []
                    };
                    groups[groupName]['value'] = groupName;
                    groups[groupName].data.push(item);
                });
                var result = [];
                for (var i in groups) {
                    result.push(groups[i]);
                }
                log('ngTable: refresh groups', result);
                return result;
            });
        };

        /**
         * @ngdoc method
         * @name NgTableParams#generatePagesArray
         * @description Generate array of pages
         *
         * @param {boolean} currentPage which page must be active
         * @param {boolean} totalItems  Total quantity of items
         * @param {boolean} pageSize    Quantity of items on page
         * @param {number} maxBlocks    Quantity of blocks for pagination
         * @returns {Array} Array of pages
         */
        this.generatePagesArray = function(currentPage, totalItems, pageSize, maxBlocks) {
            var maxPage, maxPivotPages, minPage, numPages, pages;
            maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;

            pages = [];
            numPages = Math.ceil(totalItems / pageSize);
            if (numPages > 1) {
                pages.push({
                    type: 'prev',
                    number: Math.max(1, currentPage - 1),
                    active: currentPage > 1
                });
                pages.push({
                    type: 'first',
                    number: 1,
                    active: currentPage > 1,
                    current: currentPage === 1
                });
                maxPivotPages = Math.round((settings.paginationMaxBlocks - settings.paginationMinBlocks) / 2);
                minPage = Math.max(2, currentPage - maxPivotPages);
                maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));
                minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));
                var i = minPage;
                while (i <= maxPage) {
                    if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {
                        pages.push({
                            type: 'more',
                            active: false
                        });
                    } else {
                        pages.push({
                            type: 'page',
                            number: i,
                            active: currentPage !== i,
                            current: currentPage === i
                        });
                    }
                    i++;
                }
                pages.push({
                    type: 'last',
                    number: numPages,
                    active: currentPage !== numPages,
                    current: currentPage === numPages
                });
                pages.push({
                    type: 'next',
                    number: Math.min(numPages, currentPage + 1),
                    active: currentPage < numPages
                });
            }
            return pages;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#isDataReloadRequired
         * @description Return true when a change to this `NgTableParams` instance should require the reload method
         * to be run so as to ensure the data presented to the user reflects the `NgTableParams`
         */
        this.isDataReloadRequired = function(){
            // note: using != as want to treat null and undefined the same
            return !isCommittedDataset || !angular.equals(params, committedParams);
        };

        /**
         * @ngdoc method
         * @name NgTableParams#hasFilter
         * @description Determines if NgTableParams#filter has significant filter value(s)
         * (any value except null, undefined, or empty string)
         * @returns {Boolean} true when NgTableParams#filter has at least one significant field value
         */
        this.hasFilter = function(){
            var currentFilter = this.filter();
            var keys = Object.keys(currentFilter);
            var result = false;
            for (var i=0; i < keys.length; i++){
                var filterValue = currentFilter[keys[i]];
                if (filterValue != null && filterValue !== '') {
                    result = true;
                    break;
                }
            }
            return result;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#hasFilterChanges
         * @description Return true when a change to `NgTableParams.filters`require the reload method
         * to be run so as to ensure the data presented to the user reflects these filters
         */
        this.hasFilterChanges = function(){
            return !angular.equals((params && params.filter), (committedParams && committedParams.filter));
        };

        /**
         * @ngdoc method
         * @name NgTableParams#url
         * @description Return groups for table grouping
         *
         * @param {boolean} asString flag indicates return array of string or object
         * @returns {Array} If asString = true will be return array of url string parameters else key-value object
         */
        this.url = function(asString) {
            asString = asString || false;
            var pairs = (asString ? [] : {});
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    var item = params[key],
                        name = encodeURIComponent(key);
                    if (typeof item === "object") {
                        for (var subkey in item) {
                            if (!angular.isUndefined(item[subkey]) && item[subkey] !== "") {
                                var pname = name + "[" + encodeURIComponent(subkey) + "]";
                                if (asString) {
                                    pairs.push(pname + "=" + item[subkey]);
                                } else {
                                    pairs[pname] = item[subkey];
                                }
                            }
                        }
                    } else if (!angular.isFunction(item) && !angular.isUndefined(item) && item !== "") {
                        if (asString) {
                            pairs.push(name + "=" + encodeURIComponent(item));
                        } else {
                            pairs[name] = encodeURIComponent(item);
                        }
                    }
                }
            }
            return pairs;
        };

        /**
         * @ngdoc method
         * @name NgTableParams#reload
         * @description Reload table data
         */
        this.reload = function() {
            var self = this,
                pData = null;

            settings.$loading = true;

            committedParams = angular.copy(params);
            isCommittedDataset = true;

            if (settings.groupBy) {
                pData = runGetGroups();
            } else {
                pData = runGetData();
            }
            pData = runInterceptorPipeline(pData);

            log('ngTable: reload data');

            var oldData = self.data;
            return pData.then(function(data) {
                settings.$loading = false;
                self.data = data;
                // note: I think it makes sense to publish this event even when data === oldData
                // subscribers can always set a filter to only receive the event when data !== oldData
                ngTableEventsChannel.publishAfterReloadData(self, data, oldData);
                self.reloadPages();

                // todo: remove after acceptable depreciation period
                if (settings.$scope) {
                    settings.$scope.$emit('ngTableAfterReloadData');
                }

                return data;
            }).catch(function(reason){
                committedParams = null;
                isCommittedDataset = false;
                // "rethrow"
                return $q.reject(reason);
            });
        };

        this.reloadPages = (function() {
            var currentPages;
            return function(){
                var oldPages = currentPages;
                var newPages = self.generatePagesArray(self.page(), self.total(), self.count());
                if (!angular.equals(oldPages, newPages)){
                    currentPages = newPages;
                    ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);
                }
            }
        })();

        function runGetData(){
            var getDataFn = settings.getDataFnAdaptor(settings.getData);
            return $q.when(getDataFn.call(settings, self));
        }

        function runGetGroups(){
            var getGroupsFn = settings.getGroupsFnAdaptor(settings.getGroups);
            return $q.when(getGroupsFn.call(settings, settings.groupBy, self));
        }

        function runInterceptorPipeline(dataFetched){
            var interceptors = settings.interceptors || [];
            return interceptors.reduce(function(result, interceptor){
                return result.then(function(data){
                    return $q.when(interceptor.response(data, self));
                });
            }, dataFetched);
        }

        var params = {
            page: 1,
            count: 1,
            filter: {},
            sorting: {},
            group: {},
            groupBy: null
        };
        angular.extend(params, ngTableDefaults.params);

        var settings = {
            // todo: remove $scope after acceptable depreciation period as no longer required
            $scope: null, // set by ngTable controller
            $loading: false,
            data: null, //allows data to be set when table is initialized
            total: 0,
            defaultSort: 'desc',
            filterDelay: 750,
            counts: [10, 25, 50, 100],
            interceptors: [],
            paginationMaxBlocks: 11,
            paginationMinBlocks: 5,
            sortingIndicator: 'span',
            getDataFnAdaptor: angular.identity,
            getGroupsFnAdaptor: angular.identity,
            getGroups: this.getGroups,
            getData: this.getData
        };

        this.settings(ngTableDefaults.settings);
        this.settings(baseSettings);
        this.parameters(baseParameters, true);

        ngTableEventsChannel.publishAfterCreated(this);

        return this;
    };
    return NgTableParams;
}]);

/**
 * @ngdoc service
 * @name ngTableParams
 * @description Backwards compatible shim for lowercase 'n' in NgTableParams
 */
app.factory('ngTableParams', ['NgTableParams', function(NgTableParams) {
    return NgTableParams;
}]);

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(){
    'use strict';

    angular.module('ngTable')
        .controller('ngTableFilterRowController', ngTableFilterRowController);

    ngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];

    function ngTableFilterRowController($scope, ngTableFilterConfig){

        $scope.config = ngTableFilterConfig;
    }
})();

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(){
    'use strict';

    angular.module('ngTable')
        .controller('ngTableSorterRowController', ngTableSorterRowController);

    ngTableSorterRowController.$inject = ['$scope'];

    function ngTableSorterRowController($scope){

        $scope.sortBy = sortBy;

        ///////////

        function sortBy($column, event) {
            var parsedSortable = $column.sortable && $column.sortable();
            if (!parsedSortable) {
                return;
            }
            var defaultSort = $scope.params.settings().defaultSort;
            var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');
            var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);
            var sortingParams = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};
            sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);
            $scope.params.parameters({
                sorting: sortingParams
            });
        }
    }
})();

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

/**
 * @ngdoc object
 * @name ngTableController
 *
 * @description
 * Each {@link ngTable ngTable} directive creates an instance of `ngTableController`
 */
app.controller('ngTableController', ['$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element',
    'ngTableColumn', 'ngTableEventsChannel', '$rootScope', '$translate',
function($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, ngTableColumn, ngTableEventsChannel, $rootScope, $translate) {
    var isFirstTimeLoad = true;
    $scope.$filterRow = {};
    $scope.$loading = false;

    // until such times as the directive uses an isolated scope, we need to ensure that the check for
    // the params field only consults the "own properties" of the $scope. This is to avoid seeing the params
    // field on a $scope higher up in the prototype chain
    if (!$scope.hasOwnProperty("params")) {
        $scope.params = new NgTableParams(true);
    }
    $scope.params.settings().$scope = $scope;

    var delayFilter = (function() {
        var timer = 0;
        return function(callback, ms) {
            $timeout.cancel(timer);
            timer = $timeout(callback, ms);
        };
    })();

    function onDataReloadStatusChange (newStatus/*, oldStatus*/) {
        if (!newStatus) {
            return;
        }
        $scope.params.settings().$scope = $scope;

        var currentParams = $scope.params;

        if (currentParams.hasFilterChanges()) {
            var applyFilter = function () {
                currentParams.page(1);
                //currentParams.reload();
            };
            if (currentParams.settings().filterDelay) {
                //delayFilter(applyFilter, currentParams.settings().filterDelay);
            } else {
                //applyFilter();
            }
        } else {
            //currentParams.reload();
        }
    }

    // watch for when a new NgTableParams is bound to the scope
    // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains
    // the current data page as a field. Checking this for value equality would be terrible for performance
    // and potentially cause an error if the items in that array has circular references
    /*$scope.$watch('params', function(newParams, oldParams){
    	if (newParams === oldParams || !newParams) {
            return;
        }
        validateFilterParamBeforeSubmit();
        //newParams.reload();
    }, false);*/
    
    
    var validateFilterParamBeforeSubmit = function(actionType){
		//looping table columns
    	if (angular.isUndefined(actionType)){ 
    		// actionType will be enterkeypress or clear
    		actionType = '';
    	}
		var filterValue, filterName, filterType, hasErrors = false;
		angular.forEach($scope.$columns, function (value, key) {
			if(!hasErrors){
				for (var filterName in value.filter()) {
					//Filter type
					filterType = value.filter()[filterName];
					
					if(filterType === 'text') {
						filterValue = $scope.params.parameters().filter[filterName];
						if(angular.isDefined(filterValue) && angular.isString(filterValue)){
							if(filterValue !=='' && !filterValue.match(/^[a-zA-Z0-9\s-*&()!@#$%^|\\/\:;?_+=.,`~'"]+$/)){
								if(actionType !== 'clear'){
									$rootScope.commonAlertDialogTitle = 'Alert';
						    		$rootScope.commonAlertDialogContent = $translate.instant('common.specialCharactersNotAllowed');
						    		$rootScope.commonAlertDialog();
									hasErrors = true;
									return;
								}else{
									$scope.params.parameters().filter[filterName] = '';
								}
								
							};
						}
					}else if(filterType === 'dateTime' || filterType === 'date' || filterType === 'dateRange' || filterType === 'dateTimeRange') {
						$('[id="'+filterName+'_From"]').removeClass("validation-invalid-filter");
						$('[id="'+filterName+'_To"]').removeClass("validation-invalid-filter");
						
						var startDate = $scope.params.parameters().filter[filterName+"_startDate"];
				    	var endDate = $scope.params.parameters().filter[filterName+"_endDate"];
				    	if(startDate){
				    		startDate = new Date(startDate);
				    	}
				    	if(endDate){
				    		endDate = new Date(endDate);
				    	}
				    
				    	if(!hasErrors && endDate !== '' && endDate !== undefined && startDate === undefined){
				    		if(actionType !== 'clear'){
				    			$('[id="'+filterName+'_From"]').focus();				    		
					    		$('[id="'+filterName+'_From"]').addClass("validation-invalid-filter");
								$rootScope.commonAlertDialogTitle = 'Alert';
					    		$rootScope.commonAlertDialogContent = 'Please select from date';
					    		$rootScope.commonAlertDialog();
					    		hasErrors = true;
					    		return;
				    		}else{
				    			$scope.params.parameters().filter[filterName+"_startDate"] = undefined;
				    			$scope.params.parameters().filter[filterName+"_endDate"] = undefined;
				    		}
				    	}else if(!hasErrors && startDate !== '' && startDate !== undefined && endDate === undefined){
				    		if(actionType !== 'clear'){
				    			$('[id="'+filterName+'_To"]').focus();
					    		$('[id="'+filterName+'_To"]').addClass("validation-invalid-filter");
					    		$rootScope.commonAlertDialogTitle = 'Alert';
					    		$rootScope.commonAlertDialogContent = 'Please select to date';
					    		$rootScope.commonAlertDialog();
					    		hasErrors = true;
					    		return;
				    		}else{
				    			$scope.params.parameters().filter[filterName+"_startDate"] = undefined;
				    			$scope.params.parameters().filter[filterName+"_endDate"] = undefined;
				    		}
				    	}
				    	if(!hasErrors && startDate !== undefined && endDate !== undefined) {
				    		if (startDate.getTime() > endDate.getTime()){
				    			if(actionType !== 'clear'){
				    				
					    			$('[id="'+filterName+'_From"]').focus();
					    			$('[id="'+filterName+'_From"]').addClass("validation-invalid-filter");
					    			$rootScope.commonAlertDialogTitle = 'Alert';
						    		$rootScope.commonAlertDialogContent = 'From date must be less than or equal to To date';
						    		$rootScope.commonAlertDialog();
						    		hasErrors = true;
						    		return;
					    		}else{
					    			$scope.params.parameters().filter[filterName+"_startDate"] = undefined;
					    			$scope.params.parameters().filter[filterName+"_endDate"] = undefined;
					    		}
				    		}else{
				    			$scope.params.parameters().filter[filterName+'_DateRangeFilter'] = $scope.params.parameters().filter[filterName+"_startDate"]+'#vmsdr#'+ $scope.params.parameters().filter[filterName+"_endDate"];
				    		}
				    	}
					} else if (filterType === 'multiselect' || filterType === 'advanced-select') {
						var columnData = value.data;
						filterValue = $scope.params.parameters().filter[filterName];
						
				    	if (angular.isArray(columnData) && angular.isArray(filterValue)){
				    		if(columnData.length === filterValue.length){
				    			$scope.params.parameters().filter[filterName+"_MultiSelectFilter"] = 'all';
				    		} else {
					    		$scope.params.parameters().filter[filterName+"_MultiSelectFilter"] = $scope.params.parameters().filter[filterName];
					    	}
				    	}
					} else if (filterType === 'number'){
						$('[id="'+filterName+'_Start"]').removeClass("validation-invalid-filter");
						$('[id="'+filterName+'_End"]').removeClass("validation-invalid-filter");
						
						var testNumber = /^\d*$/;
				    	var numberOption = ($scope.params.parameters().filter[filterName+'_options']) ? $scope.params.parameters().filter[filterName+'_options'].id : '?';
				    	var numberStart = $scope.params.parameters().filter[filterName+'_start'];
				    	var numberEnd = $scope.params.parameters().filter[filterName+'_end'];
				    	if(angular.isDefined(numberOption) && numberOption !== ' ' && numberOption !== '' && numberOption !== '?'){
				    		numberStart = numberStart.replace('$','');
					    	numberStart = numberStart.replace(',','');
					    	numberEnd = numberEnd.replace('$','');
					    	numberEnd = numberEnd.replace(',','');
					    	$scope.params.parameters().filter[filterName+'_start']= numberStart;			    	
							$scope.params.parameters().filter[filterName+'_end']= numberEnd;
					    	switch(numberOption){
					    		case 'btw':
					    				if(!hasErrors && (!checkIsNumber(numberStart) || numberStart === '')){
					    					if(actionType !== 'clear'){
						    					$('[id="'+filterName+'_Start"]').focus();
						    					$('[id="'+filterName+'_Start"]').addClass("validation-invalid-filter");
						    					$rootScope.commonAlertDialogTitle = 'Alert';
						    		    		$rootScope.commonAlertDialogContent = 'Please enter start value in number filter.';
						    		    		$rootScope.commonAlertDialog();
						    		    		hasErrors = true;
						    		    		return;
					    					}else{
					    						$scope.params.parameters().filter[filterName+"_options"] = undefined;
								    			$scope.params.parameters().filter[filterName+"_start"] = undefined;
								    			$scope.params.parameters().filter[filterName+"_end"] = undefined;
								    		}
					    				}else if(!hasErrors && (!checkIsNumber(numberEnd) || numberEnd === '')){
					    					if(actionType !== 'clear'){
						    					$('[id="'+filterName+'_End"]').focus();
						    					$('[id="'+filterName+'_End"]').addClass("validation-invalid-filter");
						    					$rootScope.commonAlertDialogTitle = 'Alert';
						    		    		$rootScope.commonAlertDialogContent = 'Please enter end value in number filter.';
						    		    		$rootScope.commonAlertDialog();
						    		    		hasErrors = true;
						    		    		return;
					    					}else{
					    						$scope.params.parameters().filter[filterName+"_options"] = undefined;
								    			$scope.params.parameters().filter[filterName+"_start"] = undefined;
								    			$scope.params.parameters().filter[filterName+"_end"] = undefined;
								    		}
					    		    	}else if(!hasErrors && parseFloat(numberStart) > parseFloat(numberEnd)){
					    		    		if(actionType !== 'clear'){
						    		    		$('[id="'+filterName+'_Start"]').focus();
						    		    		$('[id="'+filterName+'_Start"]').addClass("validation-invalid-filter");
						    					$rootScope.commonAlertDialogTitle = 'Alert';
						    		    		$rootScope.commonAlertDialogContent = 'From value must be less than or equal to To value.';
						    		    		$rootScope.commonAlertDialog();
						    		    		hasErrors = true;
						    		    		return;
						    		    	}else{
					    						$scope.params.parameters().filter[filterName+"_options"] = undefined;
								    			$scope.params.parameters().filter[filterName+"_start"] = undefined;
								    			$scope.params.parameters().filter[filterName+"_end"] = undefined;
								    		}
					    		    	}else{
					    					$scope.params.parameters().filter[filterName] = numberStart +'#btw#'+ numberEnd;
					    				}
					    			break;
					    		default:
					    			if(!hasErrors && (!checkIsNumber(numberEnd) || numberEnd === '')){
					    				if(actionType !== 'clear'){
						    				$('[id="'+filterName+'_End"]').focus();
						    				$('[id="'+filterName+'_End"]').addClass("validation-invalid-filter");
											$rootScope.commonAlertDialogTitle = 'Alert';
								    		$rootScope.commonAlertDialogContent = 'Please enter value in number filter.';
								    		$rootScope.commonAlertDialog();
								    		hasErrors = true;
								    		return;
						    			}else{
				    						$scope.params.parameters().filter[filterName+"_options"] = undefined;
							    			$scope.params.parameters().filter[filterName+"_start"] = undefined;
							    			$scope.params.parameters().filter[filterName+"_end"] = undefined;
							    		}
									}else{
										if(numberOption === 'eq'){
											$scope.params.parameters().filter[filterName] = numberEnd;
										}else if (numberOption === ' '){
											$scope.params.parameters().filter[filterName] = '';
										}else{
											$scope.params.parameters().filter[filterName] = '#' +numberOption+ '#'+ numberEnd;
										}
									}
					    			break;    	
					    	}
				    	}
					}
				}
			}
		});
		if(!hasErrors){
			$scope.params.parameters().page = 1;
			$scope.params.parameters().saveDefaultReport = true;
			if($scope.checkAll){
				$scope.checkAll.checked = false;
				$scope.checkAll.itemsChecked = {};
				$scope.checkAll.itemsSelected = [];
			}
			$scope.params.reload();
		}
	} 
    
    var checkIsNumber= function (text) {
    	var dot = text.indexOf(".");
    	if (dot != -1) {
    		var dotArr = text.split(".");
    		
    		if (dotArr.length >= 2) {
    			text = dotArr[0] + "." +dotArr[1];
    		}
    		if (dotArr.length > 2) {			
    			return false;
    		}
    	}
    	
    	if (!text.match(/^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/)) {
    		return false;
    	}
    	return true;
    };
    
	$scope.$watch('params.parameters().sorting', function (newParams, oldParams) {
		$scope.params.settings().$scope = $scope;
		if (!angular.equals(newParams, oldParams)) {
			if($scope.$data && $scope.$data.length>0){
				$scope.params.parameters().page = 1;
				if($scope.checkAll){
					$scope.checkAll.checked = false;
					$scope.checkAll.itemsChecked = {};
					$scope.checkAll.itemsSelected = [];
				}
				$scope.params.reload();
			}
		}
	}, true);
	
	
	$scope.$watch('params.parameters().page', function (newParams, oldParams) {
		$scope.params.settings().$scope = $scope;
		if (!angular.equals(newParams, oldParams)) {
			$scope.params.reload();
		}
	}, true);
	
	$scope.$watch('params.parameters().count', function (newParams, oldParams) {
		$scope.params.settings().$scope = $scope;
		if (!angular.equals(newParams, oldParams)) {
			$scope.params.parameters().page = 1;
			if($scope.checkAll){
				$scope.checkAll.checked = false;
				$scope.checkAll.itemsChecked = {};
				$scope.checkAll.itemsSelected = [];
			}
			$scope.params.reload();
		}
	}, true);
	
	$scope.$watch('params.parameters().group', function (newParams, oldParams) {
		$scope.params.settings().$scope = $scope;
		if (!angular.equals(newParams, oldParams)) {
			$scope.params.reload();
		}
	}, true);

	$scope.sortBy = function (column, event) {
		if($scope.$data && $scope.$data.status === 'error'){
			return;
		}
		var parsedSortable = $scope.parse(column.sortable);
		if (!parsedSortable) {
			return;
		}
		var settings = $scope.params.settings();
		var defaultSort = settings.defaultSort;
		var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');
		var multipleSort = (event.ctrlKey || event.metaKey);

		var sorting = $scope.params.sorting(), newSort = defaultSort;
		if (sorting && sorting[parsedSortable]) {

			if (settings.allowUnsort) {
				if (sorting[parsedSortable] === defaultSort) {
					newSort = inverseSort;
				} else if (sorting[parsedSortable] === inverseSort) {
					newSort = false;
				} else {
					newSort = defaultSort;
				}
			} else {
				newSort = sorting[parsedSortable] === defaultSort ? inverseSort : defaultSort;
			}
		}
		var sortingParams = multipleSort ? $scope.params.sorting() : {};
		if (newSort) {
			sortingParams[parsedSortable] = newSort;
		} else {
			delete sortingParams[parsedSortable];
		}

		$scope.params.parameters({
			sorting: sortingParams
		});
	};
	
	//VM Changes 
	$scope.doTextSubmit = function(keyEvent) {
		if (keyEvent.which === 13){
			validateFilterParamBeforeSubmit();
    	}
    };
    
    //VM Changes - Multiselect Dropdown Event
    $scope.doMultiSelectFilter = function(event, column, name) {
    	validateFilterParamBeforeSubmit();
    };
    
    //VM Changes 
    $scope.doDropDownChange = function() {
    	validateFilterParamBeforeSubmit();
    };
    
    //VM Changes 
    $scope.doDateFilter = function(keyEvent, startDateName, endDateName) {
	    if (keyEvent.which === 13){
	    	validateFilterParamBeforeSubmit();
    	}
    };
    
    //VM Changes 
    $scope.clearDateFilter = function(startDateName, endDateName) {
    	var startDate = $scope.params.parameters().filter[startDateName];
    	var endDate = $scope.params.parameters().filter[endDateName];
    	if(startDate !== undefined){
    		$scope.params.parameters().filter[startDateName.split('_')[0]] = '';
    		$scope.params.parameters().filter[startDateName] = undefined;
    		delete $scope.params.parameters().filter[startDateName];
    	} 
    	if (endDate !== undefined ){
    		$scope.params.parameters().filter[endDateName.split('_')[0]] = '';
    		$scope.params.parameters().filter[endDateName] = undefined;
    		delete $scope.params.parameters().filter[endDateName];
    	}
    	delete $scope.params.parameters().filter[startDateName.split('_')[0]+'_DateRangeFilter'];
    	validateFilterParamBeforeSubmit('clear');
    };
    
    //VM Changes 
    $scope.clearNumberFilter = function(optionsVal, startVal, endVal){
    	$scope.params.parameters().filter[optionsVal] = undefined;
    	$scope.params.parameters().filter[startVal] = undefined;
    	$scope.params.parameters().filter[endVal] = undefined;
    	$scope.params.parameters().filter[optionsVal.split('_')[0]] ='';
    	validateFilterParamBeforeSubmit('clear');
    };
    
    //VM Changes - Number Filter
    $scope.doNumberFilter = function(keyEvent, optionsVal, startVal, endVal) {
    	if (keyEvent.which === 13){
    		validateFilterParamBeforeSubmit();
    	}
    };
    
  //VM Changes - Clear Number Filter If Select Empty Value From Dropdown  
    $scope.changeNumberFilter=function(numberModel, optionsVal, startVal, endVal){	    	    	
    	if(numberModel.trim() === ''){	    			
    		$scope.clearNumberFilter(optionsVal, startVal, endVal);	
    	}
    };
    
    $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);

    this.compileDirectiveTemplates = function () {
        /*if (!$element.hasClass('ng-table')) {
            $scope.templates = {
                header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),
                pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')
            };
            $element.addClass('ng-table');
            var headerTemplate = null;

            // $element.find('> thead').length === 0 doesn't work on jqlite
            var theadFound = false;
            angular.forEach($element.children, function(e) {
                if (e.tagName === 'THEAD') {
                    theadFound = true;
                }
            });
            if (!theadFound) {
                headerTemplate = angular.element(document.createElement('thead')).attr('ng-include', 'templates.header');
                $element.prepend(headerTemplate);
            }
            var paginationTemplate = angular.element(document.createElement('div')).attr({
                'ng-table-pagination': 'params',
                'template-url': 'templates.pagination'
            });
            $element.after(paginationTemplate);
            if (headerTemplate) {
                $compile(headerTemplate)($scope);
            }
            $compile(paginationTemplate)($scope);
        }*/
    	
    	if (!$element.hasClass('ng-table')) {
    		$scope.templates = {
    			header: function() {
    				if($attrs.filterPosition === 'top') {
    					return (attrs.templateHeader ? $attrs.templateHeader : 'ng-table/headerFilterTop.html');
    				}
    				return ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html');
    			}(),
    			pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')
    		};
    		var thead = $element.find('thead');
    		var headerTemplate = thead.length > 0 ? thead : angular.element(document.createElement('thead')).attr('ng-include', 'templates.header');

    		if ($element.hasClass('has-pager')) {
    			var paginationRow = angular.element(document.createElement('tr'))
    					.append(angular.element(document.createElement('td'))
    						.attr({
    							'ng-table-pagination': 'params',
    							'template-url': 'templates.pagination',
    							'colspan': columns.length
    						})),
    				paginationTemplate = angular.element(document.createElement('tfoot')).append(paginationRow);

    			$element.append(paginationTemplate);
    			$compile(paginationTemplate)($scope);
    		}

    		$element.find('thead').remove();
    		$element.addClass('ng-table').prepend(headerTemplate)

    		$compile(headerTemplate)($scope);
    	}
    };

    this.loadFilterData = function ($columns) {
        angular.forEach($columns, function ($column) {
            var def;
            def = $column.filterData($scope, {
                $column: $column
            });
            if (!def) {
                delete $column.filterData;
                return;
            }

            // if we're working with a deferred object, let's wait for the promise
            if ((angular.isObject(def) && angular.isObject(def.promise))) {
                delete $column.filterData;
                return def.promise.then(function(data) {
                    // our deferred can eventually return arrays, functions and objects
                    if (!angular.isArray(data) && !angular.isFunction(data) && !angular.isObject(data)) {
                        // if none of the above was found - we just want an empty array
                        data = [];
                    } else if (angular.isArray(data)) {
                        data.unshift({
                            title: '-',
                            id: ''
                        });
                    }
                    $column.data = data;
                });
            }
            // otherwise, we just return what the user gave us. It could be a function, array, object, whatever
            else {
                return $column.data = def;
            }
        });
    };

    this.buildColumns = function (columns) {
        return columns.map(function(col){
            return ngTableColumn.buildColumn(col, $scope)
        })
    };

    this.parseNgTableDynamicExpr = function (attr) {
        if (!attr || attr.indexOf(" with ") > -1) {
            var parts = attr.split(/\s+with\s+/);
            return {
                tableParams: parts[0],
                columns: parts[1]
            };
        } else {
            throw new Error('Parse error (expected example: ng-table-dynamic=\'tableParams with cols\')');
        }
    };

    this.setupBindingsToInternalScope = function(tableParamsExpr){

        // note: this we're setting up watches to simulate angular's isolated scope bindings

        // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than
        // $watch for value equivalence. This is because ngTableParams references the current page of data as
        // a field and it's important not to watch this
        var tableParamsGetter = $parse(tableParamsExpr);
        $scope.$watch(tableParamsGetter, (function (params) {
            if (angular.isUndefined(params)) {
                return;
            }
            $scope.paramsModel = tableParamsGetter;
            $scope.params = params;
        }), false);

        if ($attrs.showFilter) {
            $scope.$parent.$watch($attrs.showFilter, function(value) {
                $scope.show_filter = value;
            });
        }
        if ($attrs.disableFilter) {
            $scope.$parent.$watch($attrs.disableFilter, function(value) {
                $scope.$filterRow.disabled = value;
            });
        }
    };



    function commonInit(){
        ngTableEventsChannel.onAfterReloadData(bindDataToScope, $scope, isMyPublisher);
        ngTableEventsChannel.onPagesChanged(bindPagesToScope, $scope, isMyPublisher);

        function bindDataToScope(params, newDatapage){
            if (params.settings().groupBy) {
                $scope.$groups = newDatapage;
            } else {
                $scope.$data = newDatapage;
            }
        }

        function bindPagesToScope(params, newPages){
            $scope.pages = newPages
        }

        function isMyPublisher(publisher){
            return $scope.params === publisher;
        }
    }

    commonInit();
}]);


/**
 * @ngdoc service
 * @name ngTableColumn
 * @module ngTable
 * @description
 * Service to construct a $column definition used by {@link ngTable ngTable} directive
 */
app.factory('ngTableColumn', [function () {

    var defaults = {
        'class': function(){ return ''; },
        filter: function(){ return false; },
        filterData: angular.noop,
        headerTemplateURL: function(){ return false; },
        headerTitle: function(){ return ''; },
        sortable: function(){ return false; },
        show: function(){ return true; },
        title: function(){ return ''; },
        titleAlt: function(){ return ''; }
    };

    /**
     * @ngdoc method
     * @name ngTableColumn#buildColumn
     * @description Creates a $column for use within a header template
     *
     * @param {Object} column an existing $column or simple column data object
     * @param {Scope} defaultScope the $scope to supply to the $column getter methods when not supplied by caller
     * @returns {Object} a $column object
     */
    function buildColumn(column, defaultScope){
        // note: we're not modifying the original column object. This helps to avoid unintended side affects
        var extendedCol = Object.create(column);
        for (var prop in defaults) {
            if (extendedCol[prop] === undefined) {
                extendedCol[prop] = defaults[prop];
            }
            if(!angular.isFunction(extendedCol[prop])){
                // wrap raw field values with "getter" functions
                // - this is to ensure consistency with how ngTable.compile builds columns
                // - note that the original column object is being "proxied"; this is important
                //   as it ensure that any changes to the original object will be returned by the "getter"
                (function(prop1){
                    extendedCol[prop1] = function(){
                        return column[prop1];
                    };
                })(prop);
            }
            (function(prop1){
                // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive
                var getterFn = extendedCol[prop1];
                extendedCol[prop1] = function(){
                    if (arguments.length === 0){
                        return getterFn.call(column, defaultScope);
                    } else {
                        return getterFn.apply(column, arguments);
                    }
                };
            })(prop);
        }
        return extendedCol;
    }

    return {
        buildColumn: buildColumn
    };
}]);

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

/**
 * @ngdoc directive
 * @name ngTable
 * @module ngTable
 * @restrict A
 *
 * @description
 * Directive that instantiates {@link ngTableController ngTableController}.
 */
app.directive('ngTable', ['$q', '$parse',
    function($q, $parse) {
        'use strict';

        return {
            restrict: 'A',
            priority: 1001,
            scope: true,
            controller: 'ngTableController',
            compile: function(element) {
                var columns = [],
                    i = 0,
                    row = null;

                // IE 8 fix :not(.ng-table-group) selector
                angular.forEach(angular.element(element.find('tr')), function(tr) {
                    tr = angular.element(tr);
                    if (!tr.hasClass('ng-table-group') && !row) {
                        row = tr;
                    }
                });
                if (!row) {
                    return;
                }
                angular.forEach(row.find('td'), function(item) {
                    var el = angular.element(item);
                    if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {
                        return;
                    }

                    var getAttrValue = function(attr){
                        return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);
                    };

                    var parsedAttribute = function(attr) {
                        var expr = getAttrValue(attr);
						if(attr === 'place-holder' && !expr){
							expr = getAttrValue('placeholder');
						}
						if (!expr){
                        	return undefined;
                        }
                        return function(scope, locals) {
                            return $parse(expr)(scope, angular.extend(locals || {}, {
                                $columns: columns
                            }));
                        };
                    };

                    var titleExpr = getAttrValue('title-alt') || getAttrValue('title');
                    if (titleExpr){
                        el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table
                    }
                    // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with
                    // a corresponding "safe" default
                    columns.push({
                        id: i++,
                        title: parsedAttribute('title'),
                        placeHolder: parsedAttribute('place-holder'),
						maxLength: function(){
							return parsedAttribute('max-length') || '100';
						},
                        titleAlt: parsedAttribute('title-alt'),
                        headerTitle: parsedAttribute('header-title'),
                        sortable: parsedAttribute('sortable'),
                        'class': parsedAttribute('header-class'),
                        filter: parsedAttribute('filter'),
                        headerTemplateURL: parsedAttribute('header'),
                        filterData: parsedAttribute('filter-data'),
                        show: (el.attr("ng-if") ? function (scope) {
                            return $parse(el.attr("ng-if"))(scope);
                        } : undefined)
                    });
                });
                return function(scope, element, attrs, controller) {
                    scope.$columns = columns = controller.buildColumns(columns);

                    controller.setupBindingsToInternalScope(attrs.ngTable);
                    controller.loadFilterData(columns);
                    controller.compileDirectiveTemplates();
                };
            }
        }
    }
]);

/**
 * @ngdoc directive
 * @name ngTableDynamic
 * @module ngTable
 * @restrict A
 *
 * @description
 * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns
 * definitions to render
 */
app.directive('ngTableDynamic', ['$parse', function ($parse){

    return {
        restrict: 'A',
        priority: 1001,
        scope: true,
        controller: 'ngTableController',
        compile: function(tElement) {
            var row;

            // IE 8 fix :not(.ng-table-group) selector
            angular.forEach(angular.element(tElement.find('tr')), function(tr) {
                tr = angular.element(tr);
                if (!tr.hasClass('ng-table-group') && !row) {
                    row = tr;
                }
            });
            if (!row) {
                return;
            }

            angular.forEach(row.find('td'), function(item) {
                var el = angular.element(item);
                var getAttrValue = function(attr){
                    return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);
                };

                // this used in responsive table
                var titleExpr = getAttrValue('title');
                if (!titleExpr){
                    el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');
                }
                var showExpr = el.attr('ng-if');
                if (!showExpr){
                    el.attr('ng-if', '$columns[$index].show(this)');
                }
            });
            return function (scope, element, attrs, controller) {
                var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);

                controller.setupBindingsToInternalScope(expr.tableParams);
                controller.compileDirectiveTemplates();

                scope.$watchCollection(expr.columns, function (newCols/*, oldCols*/) {
                    scope.$columns = controller.buildColumns(newCols);
                    controller.loadFilterData(scope.$columns);
                });
            };
        }
    };
}]);

(function(){
    'use strict';

    angular.module('ngTable')
        .directive('ngTableFilterRow', ngTableFilterRow);

    ngTableFilterRow.$inject = [];

    function ngTableFilterRow(){
        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'ng-table/filterRow.html',
            scope: true,
            controller: 'ngTableFilterRowController'
        };
        return directive;
    }
})();

(function(){
    'use strict';

    angular.module('ngTable')
        .directive('ngTableSorterRow', ngTableSorterRow);

    ngTableSorterRow.$inject = [];

    function ngTableSorterRow(){
        var directive = {
            restrict: 'E',
            replace: true,
            templateUrl: 'ng-table/sorterRow.html',
            scope: true,
            controller: 'ngTableSorterRowController'
        };
        return directive;
    }
})();

/**
 * ngTable: Table + Angular JS
 *
 * @author Vitalii Savchuk <esvit666@gmail.com>
 * @url https://github.com/esvit/ng-table/
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

/**
 * @ngdoc directive
 * @name ngTablePagination
 * @module ngTable
 * @restrict A
 */
/*app.directive('ngTablePagination', ['$compile',
    function($compile) {
        'use strict';

        return {
            restrict: 'A',
            scope: {
                'params': '=ngTablePagination',
                'templateUrl': '='
            },
            replace: false,
            link: function(scope, element, attrs) {

                var settings = scope.params.settings();
                settings.$scope.$on('ngTableAfterReloadData', function() {
                    var page = scope.params.page(),
                        total = scope.params.total(),
                        count = scope.params.count(),
                        maxBlocks = settings.paginationMaxBlocks;
                    scope.pages = scope.params.generatePagesArray(page, total, count, maxBlocks);
                }, true);

                scope.$watch('templateUrl', function(templateUrl) {
                    if (angular.isUndefined(templateUrl)) {
                        return;
                    }
                    var template = angular.element(document.createElement('div'))
                    template.attr({
                        'ng-include': 'templateUrl'
                    });
                    element.append(template);
                    $compile(template)(scope);
                });
            }
        };
    }
]);*/

app.directive('ngTablePagination', ['$compile',
	function ($compile) {
		'use strict';

		return {
			restrict: 'A',
			scope: {
				params: '=ngTablePagination',
				templateUrl: '='
			},
			replace: false,
			link: function (scope, element, attrs) {
				var getPages = function () {
					return scope.params.generatePagesArray(scope.params.page(), scope.params.total(), scope.params.count());
				};
				scope.$watch("params", function(params){
					if (angular.isUndefined(params)) {
						return;
					}
					scope.params.settings().$scope && scope.params.settings().$scope.$on('ngTableAfterReloadData', function () {
						scope.pages = getPages();
					}, true);
					
					scope.$watch(function () {
						return '' + scope.params.total() + scope.params.page() + scope.params.count();
					}, function (newVal, oldVal) {
						if (newVal !== oldVal) {
							scope.pages = getPages();
							if (scope.params.parameters().type === 'server'){
								scope.params.reload();	
							}
						}
					});
				});
				
				scope.$watch('templateUrl', function (templateUrl) {
					if (angular.isUndefined(templateUrl)) {
						return;
					}
					var template = angular.element(document.createElement('div'))
					template.attr({
						'ng-include': 'templateUrl'
					});
					element.append(template);
					$compile(template)(scope);
				});
			}
		};
	}
]);

angular.module('ngTable').run(['$templateCache', function ($templateCache) {
	$templateCache.put('ng-table/filterRow.html', '<tr ng-show="show_filter" class="ng-table-filters"> <th data-title-text="{{$column.titleAlt(this) || $column.title(this)}}" ng-repeat="$column in $columns" ng-if="$column.show(this)" class="filter"> <div ng-repeat="(name, filter) in $column.filter(this)"> <div ng-include="config.getTemplateUrl(filter)"></div> </div> </th> </tr> ');
	$templateCache.put('ng-table/filters/select-multiple.html', '<select ng-options="data.id as data.title for data in $column.data" ng-disabled="$filterRow.disabled" multiple ng-multiple="true" ng-model="params.filter()[name]" ng-if="filter==\'select-multiple\'" class="filter filter-select-multiple form-control" name="{{::name}}"> </select> ');
	$templateCache.put('ng-table/filters/select.html', '<select ng-options="data.id as data.title for data in $column.data" ng-disabled="$filterRow.disabled" ng-model="params.filter()[name]" ng-if="filter==\'select\'"  class="filter filter-select form-control" name="{{::name}}" ng-change="doDropDownChange($event)"> </select> ');
	$templateCache.put('ng-table/filters/advanced-select.html', '<button type="button" id="advancedSelectButton_{{name}}" class="btn btn-primary" data-ng-if="params.filter()[name].length>0" data-ng-click="advancedSelectMultiselect($column,params)">{{params.filter()[name].length}} Selected</button><button type="button" id="advancedSelectButton_{{name}}" class="btn btn-primary" data-ng-if="!params.filter()[name] || params.filter()[name].length==0" data-ng-click="advancedSelectMultiselect($column,params)">Select</button>');
	$templateCache.put('ng-table/filters/text.html', '<input type="text" data-ng-init="textFilterMaxLength=$column.maxLength();" id="{{name}}" placeholder="{{$column.placeHolder(this) || $column.title(this) || $column.titleAlt(this)}}" ng-keyup="doTextSubmit($event)" maxlength="{{::textFilterMaxLength?textFilterMaxLength:100}}" name="{{::name}}" ng-disabled="$filterRow.disabled" ng-model-options="{ debounce: 50 }"  ng-model="params.filter()[name]" ng-if="filter==\'text\'" class="input-filter form-control"/>');
	$templateCache.put('ng-table/header.html', '<ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> ');
	$templateCache.put('ng-table/pager.html', '<div class="ng-cloak ng-table-pager" ng-if="params.data.length"> <div ng-if="params.settings().counts.length" class="ng-table-counts btn-group pull-right"> <button ng-repeat="count in params.settings().counts" type="button" ng-class="{\'active\':params.count()==count}" ng-click="params.count(count)" class="btn btn-default"> <span ng-bind="count"></span> </button> </div> <ul class="pagination ng-table-pagination pull-left" ng-show="pages.length"> <li ng-class="{\'disabled\': !page.active && !page.current, \'active\': page.current}" ng-repeat="page in pages" ng-switch="page.type"> <a ng-switch-when="prev" ng-click="params.page(page.number)" href="">&laquo;</a> <a ng-switch-when="first" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a> <a ng-switch-when="page" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a> <a ng-switch-when="more" ng-click="params.page(page.number)" href="">&#8230;</a> <a ng-switch-when="last" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a> <a ng-switch-when="next" ng-click="params.page(page.number)" href="">&raquo;</a> </li> </ul> <ul class="pagination ng-table-pagination pull-left" ng-show="!pages.length && params.settings().total>0"><li ng-class="{\'disabled\': true}"><a href=""><span class="fa fa-chevron-left"></span>&nbsp;</a><a href="" class="disabledPaginationItem"><span>1</span></a><a href="">&nbsp;<span class="fa fa-chevron-right"></span></a></li></ul> <div class="pull-left tableTotalRecords" ng-show="params.settings().total>0">{{((params.page()*params.count())-params.count())+1}} - {{(params.page()*params.count())-(params.count()-params.data.length)}} of {{params.settings().total}}</div> </div> ');
	$templateCache.put('ng-table/sorterRow.html', '<tr> <th title="{{::$column.headerTitle(this)}}" ng-repeat="$column in $columns" ng-class="{ \'sortable\': $column.sortable(this), \'sort-asc\': params.sorting()[$column.sortable(this)]==\'asc\', \'sort-desc\': params.sorting()[$column.sortable(this)]==\'desc\' }" ng-click="sortBy($column, $event)" ng-if="$column.show(this)" ng-init="template=$column.headerTemplateURL(this)" class="header {{$column.class(this)}}"> <div ng-if="!template" class="ng-table-header" ng-class="{\'sort-indicator\': params.settings().sortingIndicator==\'div\'}"> <span ng-bind="$column.title(this)" ng-class="{\'sort-indicator\': params.settings().sortingIndicator==\'span\'}"></span> </div> <div ng-if="template" ng-include="template"></div> </th> </tr> ');
	$templateCache.put('ng-table/filters/date.html', 
			'<div class="vision-date-filter">'+
			'	<input type="text" id="{{name}}" placeholder="{{$column.placeHolder(this) || $column.title(this) || $column.titleAlt(this)}}"  class="form-control pull-left input-filter" style="background-color:#fff;min-width:90px;width:70%;float:left;" ng-model-options="{ debounce: 50 }"  datepicker-popup="{time: false, format: \'timestamp\'}" ng-keyup="doTextSubmit($event)" ng-model="params.filter()[name]" readonly>'+
			'	<button type="button" class="btn btn-primary btn-filter pull-left" ng-click="clearDateFilter(name)">Clear</button>'+
			'</div>');
	$templateCache.put('ng-table/filters/dateTime.html', 
			'<div class="vision-date-filter">'+
			'	<input type="text" id="{{name}}" placeholder="{{$column.placeHolder(this) || $column.title(this) || $column.titleAlt(this)}}"  class="form-control pull-left input-filter" style="background-color:#fff;min-width:90px;width:70%;float:left;" datepicker-popup="{time: true, format: \'timestamp\'}"  ng-keypress="doTextSubmit($event)" ng-model="params.filter()[name]" readonly>'+
			'	<button type="button" class="btn btn-primary btn-filter pull-left" ng-click="clearDateFilter(name)">Clear</button>'+
			'</div>');
	
	$templateCache.put('ng-table/filters/dateRange.html', 
			'<div class="vision-date-filter" ng-init="startDateName = name+\'_startDate\'; endDateName = name+\'_endDate\';">'+
			'	<input type="text" id="{{name}}_From" class="form-control pull-left input-filter" placeholder="From" style="background-color:#fff;min-width:90px;width:35%;float:left;" ng-model-options="{ debounce: 50 }"  datepicker-popup="{time: false, format: \'timestamp\'}" ng-keyup="doDateFilter($event, startDateName, endDateName)" ng-model="params.filter()[startDateName]" readonly>'+
			'	<input type="text" id="{{name}}_To" class="form-control pull-left input-filter" placeholder="To" style="background-color:#fff;min-width:90px;width:35%;float:left;" ng-model-options="{ debounce: 50 }"  datepicker-popup="{time: false, format: \'timestamp\'}" ng-keyup="doDateFilter($event, startDateName, endDateName)" ng-model="params.filter()[endDateName]" readonly>'+
			'	<button type="button" class="btn btn-primary btn-filter pull-left" ng-click="clearDateFilter(startDateName, endDateName)">Clear</button>'+
			'</div>'
			);
	
	$templateCache.put('ng-table/filters/dateTimeRange.html', 
			'<div class="vision-date-filter" ng-init="startDateName = name+\'_startDate\'; endDateName = name+\'_endDate\';">'+
			'	<input type="text" id="{{name}}_From" class="form-control pull-left" placeholder="From" style="background-color:#fff;min-width:90px;width:35%;float:left;" datepicker-popup="{time: true, format: \'timestamp\'}" ng-keypress="doDateFilter($event, startDateName, endDateName)" ng-model="params.filter()[startDateName]" readonly>'+
			'	<input type="text" id="{{name}}_To" class="form-control pull-left" placeholder="To" style="background-color:#fff;min-width:90px;width:35%;float:left;" datepicker-popup="{time: true, format: \'timestamp\'}" ng-keypress="doDateFilter($event, startDateName, endDateName)" ng-model="params.filter()[endDateName]" readonly>'+
			'	<button type="button" class="btn btn-primary btn-filter pull-left" ng-click="clearDateFilter(startDateName, endDateName)">Clear</button>'+
			'</div>'
	);
	
	$templateCache.put('ng-table/filters/number.html','<div class="form-inline" ng-init="optionsValName = name+\'_options\'; startValName = name+\'_start\'; endValName = name+\'_end\'; showStartVal=(params.filter()[optionsValName].id == \'btw\') ? true:false;numberFilterMaxLength=$column.maxLength(); ">'+
		   '<input id="{{name}}_Start" class="input-filter form-control pull-left" maxlength="{{::numberFilterMaxLength?numberFilterMaxLength:13}}" placeholder="{{$column.placeHolder()}}" style="background-color:#fff;width:50px;float:left;" ng-keyup="doNumberFilter($event, optionsValName, startValName, endValName)" type="text" ng-model="params.filter()[startValName]" ng-show="params.filter()[optionsValName].id == \'btw\' && showStartVal" />'+
		   '<select id="{{name}}_Options" class="filter filter-select form-control pull-left" style="float:left;" ng-style="{ \'width\' : (showStartVal) ? \'60px\':\'60px\'}" ng-options="data.title for data in $column.data track by data.id" ng-model="params.filter()[optionsValName]" ng-change="changeNumberFilter(params.filter()[optionsValName].id,optionsValName, startValName, endValName);params.filter()[startValName]=\'\';params.filter()[endValName]=\'\';showStartVal=(params.filter()[optionsValName].id == \'btw\') ? true:false;"><option value="" ng-if="false"></option></select>'+		
		   '<input id="{{name}}_End" class="input-filter form-control pull-left" maxlength="{{::numberFilterMaxLength?numberFilterMaxLength:13}}" placeholder="{{$column.placeHolder()}}" ng-readonly="params.filter()[optionsValName].id == \'\' || params.filter()[optionsValName].id == \' \' || !params.filter()[optionsValName].id" style="width:50px;float:left;" type="text" ng-model="params.filter()[endValName]"  ng-keyup="doNumberFilter($event, optionsValName, startValName, endValName)"/>'+
		   '<button type="button" class="btn btn-primary pull-left btn-filter" ng-click="showStartVal = false; clearNumberFilter(optionsValName, startValName, endValName)">Clear</button>'+
		   '</div>');
	$templateCache.put('ng-table/filters/multiselect.html','<div class="form-inline pull-left"><div filter-class-name="{{name}}MultiSelectFilterClass" ng-dropdown-multiselect options="$column.data" style="float:left;" selected-model="params.filter()[name]"></div><button type="button" class="btn btn-primary btn-filter" style="float:left;" ng-click="doMultiSelectFilter($event, column, name)">Go</button></div>');
	
	$templateCache.put('ng-table/style1.html',
			'<div class="bottom">'+
			'	<div ng-if="params.settings().counts.length" id="allocateCargoTable_length" class="dataTables_length">'+
			'		<div class="dataTables_paginate paging_bs_normal">'+
			'			<ul class="pagination ng-table-pagination pull-left" ng-show="pages.length">'+
			'				<li ng-class="{\'disabled\': !page.active && !page.current, \'active\': page.current}" ng-repeat="page in pages" ng-switch="page.type">'+
			'       			<a ng-switch-when="prev" ng-click="params.page(page.number)" href=""><span class="fa fa-chevron-left"></span>&nbsp;</a>'+
			'            		<a ng-switch-when="first" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'            		<a ng-switch-when="page" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'		            <a ng-switch-when="more" ng-click="params.page(page.number)" href="">&#8230;</a>'+
			'		            <a ng-switch-when="last" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'		            <a ng-switch-when="next" ng-click="params.page(page.number)" href="">&nbsp;<span class="fa fa-chevron-right"></span></a>'+
			'		        </li>'+
			'			</ul>'+
			'			<ul class="pagination ng-table-pagination pull-left" ng-show="!pages.length && params.settings().total>0">'+
			'				<li ng-class="{\'disabled\': true}">'+
			'       			<a href=""><span class="fa fa-chevron-left"></span>&nbsp;</a>'+
			'            		<a href="" class="disabledPaginationItem"><span>1</span></a>'+
			'		            <a href="">&nbsp;<span class="fa fa-chevron-right"></span></a>'+
			'		        </li>'+
			'			</ul>'+
			'			<div class="pull-left tableTotalRecords" ng-show="params.settings().total>0">{{((params.page()*params.count())-params.count())+1}} - {{(params.page()*params.count())-(params.count()-params.data.length)}} of {{params.settings().total}}'+
			'		    </div>'+
			'			<div class="btn-group pull-right" ng-show="params.settings().total>0">'+
			'				<button type="button" ng-class="{\'active\':params.count() == 5}" ng-click="params.count(5)" class="btn btn-default">5</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 10}" ng-click="params.count(10)" class="btn btn-default">10</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 25}" ng-click="params.count(25)" class="btn btn-default">25</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 50}" ng-click="params.count(50)" class="btn btn-default">50</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 100}" ng-click="params.count(100)" class="btn btn-default">100</button>'+
			'			</div>'+
			'		</div>'+
			'	<div>'+
			'</div>');	
	
	$templateCache.put('ng-table/style2.html',
			'<div class="bottom">'+
			'	<div ng-if="params.settings().counts.length" id="allocateCargoTable_length" class="dataTables_length">'+
			'		<div class="dataTables_paginate paging_bs_normal">'+
			'			<ul class="pagination ng-table-pagination pull-left" ng-show="pages.length">'+
			'				<li ng-class="{\'disabled\': !page.active && !page.current, \'active\': page.current}" ng-repeat="page in pages" ng-switch="page.type">'+
			'       			<a ng-switch-when="prev" ng-click="params.page(page.number)" href=""><span class="fa fa-chevron-left"></span>&nbsp;</a>'+
			'            		<a ng-switch-when="first" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'            		<a ng-switch-when="page" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'		            <a ng-switch-when="more" ng-click="params.page(page.number)" href="">&#8230;</a>'+
			'		            <a ng-switch-when="last" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'		            <a ng-switch-when="next" ng-click="params.page(page.number)" href="">&nbsp;<span class="fa fa-chevron-right"></span></a>'+
			'		        </li>'+
			'			</ul>'+
			'			<ul class="pagination ng-table-pagination pull-left" ng-show="!pages.length && params.settings().total>0">'+
			'				<li ng-class="{\'disabled\': true}">'+
			'       			<a href=""><span class="fa fa-chevron-left"></span>&nbsp;</a>'+
			'            		<a href="" class="disabledPaginationItem"><span>1</span></a>'+
			'		            <a href="">&nbsp;<span class="fa fa-chevron-right"></span></a>'+
			'		        </li>'+
			'			</ul>'+
			'			<div class="pull-left tableTotalRecords" ng-show="params.settings().total>0">{{((params.page()*params.count())-params.count())+1}} - {{(params.page()*params.count())-(params.count()-params.data.length)}} of {{params.settings().total}}'+
			'		    </div>'+
			'			<div class="btn-group pull-right" ng-show="params.settings().total>0">'+
			'				<button type="button" ng-class="{\'active\':params.count() == 5}" ng-click="params.count(5)" class="btn btn-default">5</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 10}" ng-click="params.count(10)" class="btn btn-default">10</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 25}" ng-click="params.count(25)" class="btn btn-default">25</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 50}" ng-click="params.count(50)" class="btn btn-default">50</button>'+
			'			</div>'+
			'		</div>'+
			'	<div>'+
			'</div>');
	
	$templateCache.put('ng-table/style3.html',
			'<div class="bottom">'+
			'	<div ng-if="params.settings().counts.length" id="allocateCargoTable_length" class="dataTables_length">'+
			'		<div class="dataTables_paginate paging_bs_normal">'+
			'			<ul class="pagination ng-table-pagination pull-left" ng-show="pages.length">'+
			'				<li ng-class="{\'disabled\': !page.active && !page.current, \'active\': page.current}" ng-repeat="page in pages" ng-switch="page.type">'+
			'       			<a ng-switch-when="prev" ng-click="params.page(page.number)" href=""><span class="fa fa-chevron-left"></span>&nbsp;</a>'+
			'            		<a ng-switch-when="first" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'            		<a ng-switch-when="page" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'		            <a ng-switch-when="more" ng-click="params.page(page.number)" href="">&#8230;</a>'+
			'		            <a ng-switch-when="last" ng-click="params.page(page.number)" href=""><span ng-bind="page.number"></span></a>'+
			'		            <a ng-switch-when="next" ng-click="params.page(page.number)" href="">&nbsp;<span class="fa fa-chevron-right"></span></a>'+
			'		        </li>'+
			'			</ul>'+
			'			<ul class="pagination ng-table-pagination pull-left" ng-show="!pages.length && params.settings().total>0">'+
			'				<li ng-class="{\'disabled\': true}">'+
			'       			<a href=""><span class="fa fa-chevron-left"></span>&nbsp;</a>'+
			'            		<a href="" class="disabledPaginationItem"><span>1</span></a>'+
			'		            <a href="">&nbsp;<span class="fa fa-chevron-right"></span></a>'+
			'		        </li>'+
			'			</ul>'+
			'			<div class="pull-left tableTotalRecords" ng-show="params.settings().total>0">{{((params.page()*params.count())-params.count())+1}} - {{(params.page()*params.count())-(params.count()-params.data.length)}} of {{params.settings().total}}'+
			'		    </div>'+
			'			<div class="btn-group pull-right" ng-show="params.settings().total>0">'+
			'				<button type="button" ng-class="{\'active\':params.count() == 5}" ng-click="params.count(5)" class="btn btn-default">5</button>'+
			'				<button type="button" ng-class="{\'active\':params.count() == 10}" ng-click="params.count(10)" class="btn btn-default">10</button>'+
			'			</div>'+
			'		</div>'+
			'	<div>'+
			'</div>');
}]);
    return app;
}));